/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { assert } from "@fluidframework/core-utils/internal";
import {
	IChannel,
	IChannelAttributes,
	IChannelFactory,
	IFluidDataStoreRuntime,
} from "@fluidframework/datastore-definitions/internal";
import {
	IDocumentStorageService,
	ISnapshotTree,
} from "@fluidframework/driver-definitions/internal";
import { readAndParse } from "@fluidframework/driver-utils/internal";
import {
	IExperimentalIncrementalSummaryContext,
	ISummaryTreeWithStats,
	ITelemetryContext,
	IGarbageCollectionData,
	IFluidDataStoreContext,
	ISummarizeResult,
	type IRuntimeMessageCollection,
} from "@fluidframework/runtime-definitions/internal";
import { addBlobToSummary } from "@fluidframework/runtime-utils/internal";
import {
	ITelemetryLoggerExt,
	DataCorruptionError,
	tagCodeArtifacts,
} from "@fluidframework/telemetry-utils/internal";

import { ChannelDeltaConnection } from "./channelDeltaConnection.js";
import { ChannelStorageService } from "./channelStorageService.js";
import { ISharedObjectRegistry } from "./dataStoreRuntime.js";

export const attributesBlobKey = ".attributes";

export interface IChannelContext {
	getChannel(): Promise<IChannel>;

	setConnectionState(connected: boolean, clientId?: string);

	/**
	 * Process messages for this channel context. The messages here are contiguous messages for this context in a batch.
	 * @param messageCollection - The collection of messages to process.
	 */
	processMessages(messageCollection: IRuntimeMessageCollection): void;

	summarize(
		fullTree?: boolean,
		trackState?: boolean,
		telemetryContext?: ITelemetryContext,
	): Promise<ISummarizeResult>;

	reSubmit(content: any, localOpMetadata: unknown): void;

	applyStashedOp(content: any): unknown;

	rollback(message: any, localOpMetadata: unknown): void;

	/**
	 * Returns the data used for garbage collection. This includes a list of GC nodes that represent this context
	 * including any of its children. Each node has a set of outbound routes to other GC nodes in the document.
	 * @param fullGC - true to bypass optimizations and force full generation of GC data.
	 */
	getGCData(fullGC?: boolean): Promise<IGarbageCollectionData>;

	/**
	 * After GC has run, called to notify this context of routes that are used in it. These are used for the following:
	 * 1. To identify if this context is being referenced in the document or not.
	 * 2. To identify if this context or any of its children's used routes changed since last summary.
	 * 3. They are added to the summary generated by this context.
	 */
	updateUsedRoutes(usedRoutes: string[]): void;

	branchChannel(options: {
		process?: "remote" | "remote&Local";
	}): Promise<{ channel: IChannel; context?: { merge() } }>;
}

export interface ChannelServiceEndpoints {
	deltaConnection: ChannelDeltaConnection;
	objectStorage: ChannelStorageService;
}

export function createChannelServiceEndpoints(
	connected: boolean,
	submitFn: (content: any, localOpMetadata: unknown) => void,
	dirtyFn: () => void,
	isAttachedAndVisible: () => boolean,
	storageService: IDocumentStorageService,
	logger: ITelemetryLoggerExt,
	tree?: ISnapshotTree,
	extraBlobs?: Map<string, ArrayBufferLike>,
): ChannelServiceEndpoints {
	const deltaConnection = new ChannelDeltaConnection(
		connected,
		(message, localOpMetadata) => submitFn(message, localOpMetadata),
		dirtyFn,
		isAttachedAndVisible,
	);
	const objectStorage = new ChannelStorageService(tree, storageService, logger, extraBlobs);

	return {
		deltaConnection,
		objectStorage,
	};
}

/** Used to get the channel's summary for the DDS or DataStore attach op */
export function summarizeChannel(
	channel: IChannel,
	fullTree: boolean = false,
	trackState: boolean = false,
	telemetryContext?: ITelemetryContext,
): ISummaryTreeWithStats {
	const summarizeResult = channel.getAttachSummary(fullTree, trackState, telemetryContext);

	// Add the channel attributes to the returned result.
	addBlobToSummary(summarizeResult, attributesBlobKey, JSON.stringify(channel.attributes));
	return summarizeResult;
}

export async function summarizeChannelAsync(
	channel: IChannel,
	fullTree: boolean = false,
	trackState: boolean = false,
	telemetryContext?: ITelemetryContext,
	incrementalSummaryContext?: IExperimentalIncrementalSummaryContext,
): Promise<ISummaryTreeWithStats> {
	const summarizeResult = await channel.summarize(
		fullTree,
		trackState,
		telemetryContext,
		incrementalSummaryContext,
	);

	// Add the channel attributes to the returned result.
	addBlobToSummary(summarizeResult, attributesBlobKey, JSON.stringify(channel.attributes));
	return summarizeResult;
}

export async function loadChannelFactoryAndAttributes(
	dataStoreContext: IFluidDataStoreContext,
	services: ChannelServiceEndpoints,
	channelId: string,
	registry: ISharedObjectRegistry,
	attachMessageType?: string,
): Promise<{ factory: IChannelFactory; attributes: IChannelAttributes }> {
	let attributes: IChannelAttributes | undefined;
	if (await services.objectStorage.contains(attributesBlobKey)) {
		attributes = await readAndParse<IChannelAttributes | undefined>(
			services.objectStorage,
			attributesBlobKey,
		);
	}

	// This is a backward compatibility case where the attach message doesn't include attributes. They must
	// include attach message type.
	// Since old attach messages will not have attributes, we need to keep this as long as we support old attach
	// messages.
	const channelFactoryType = attributes ? attributes.type : attachMessageType;
	if (channelFactoryType === undefined) {
		throw new DataCorruptionError(
			"channelTypeNotAvailable",
			tagCodeArtifacts({
				channelId,
				dataStoreId: dataStoreContext.id,
				dataStorePackagePath: dataStoreContext.packagePath.join("/"),
				channelFactoryType,
			}),
		);
	}
	const factory = registry.get(channelFactoryType);
	if (factory === undefined) {
		throw new DataCorruptionError(
			"channelFactoryNotRegisteredForGivenType",
			tagCodeArtifacts({
				channelId,
				dataStoreId: dataStoreContext.id,
				dataStorePackagePath: dataStoreContext.packagePath.join("/"),
				channelFactoryType,
			}),
		);
	}
	// This is a backward compatibility case where the attach message doesn't include attributes. Get the attributes
	// from the factory.
	attributes = attributes ?? factory.attributes;
	return { factory, attributes };
}

export async function loadChannel(
	dataStoreRuntime: IFluidDataStoreRuntime,
	attributes: IChannelAttributes,
	factory: IChannelFactory,
	services: ChannelServiceEndpoints,
	logger: ITelemetryLoggerExt,
	channelId: string,
): Promise<IChannel> {
	// Compare snapshot version to collaborative object version
	if (
		attributes.snapshotFormatVersion !== undefined &&
		attributes.snapshotFormatVersion !== factory.attributes.snapshotFormatVersion
	) {
		logger.sendTelemetryEvent({
			eventName: "ChannelAttributesVersionMismatch",
			...tagCodeArtifacts({
				channelType: attributes.type,
				channelSnapshotVersion: `${attributes.snapshotFormatVersion}@${attributes.packageVersion}`,
				channelCodeVersion: `${factory.attributes.snapshotFormatVersion}@${factory.attributes.packageVersion}`,
			}),
		});
	}

	return factory.load(dataStoreRuntime, channelId, services, attributes);
}

export async function branchChannel(
	options: { process?: "remote" | "remote&Local" },
	channel: IChannel,
	channelServices: ChannelServiceEndpoints,
	dataStoreRuntime: IFluidDataStoreRuntime,
	factory: IChannelFactory,
	logger: ITelemetryLoggerExt,
) {
	const services: ChannelServiceEndpoints = {
		deltaConnection: ChannelDeltaConnection.clone(channelServices.deltaConnection, {
			submit: () => {},
			dirty: () => {},
		}),
		objectStorage: channelServices.objectStorage,
	};

	if (factory.branch) {
		return {
			channel: await factory.branch(options, services, channel),
			services,
			// merge would probably come from the channel itself
			merge: undefined,
		};
	}

	const branch = {
		channel: await loadChannel(
			dataStoreRuntime,
			channel.attributes,
			factory,
			services,
			logger,
			channel.id,
		),
		services,
		merge:
			options.process === undefined
				? undefined
				: options.process === "remote"
					? createRemoteProcessingMerge(
							services.deltaConnection,
							channelServices.deltaConnection,
						)
					: createRemoteAndLocalProcessingMerge(
							services.deltaConnection,
							channelServices.deltaConnection,
						),
	};

	return branch;
}

function createRemoteProcessingMerge(
	branchDelta: ChannelDeltaConnection,
	channelDelta: ChannelDeltaConnection,
) {
	const branchPending: {
		content: unknown;
		branchMetadata: unknown;
		channelMetadata?: unknown;
	}[] = [];
	let ignoreChannelSubmits = false;

	channelDelta.on("process", (msg) => {
		if (!ignoreChannelSubmits) {
			branchDelta.processMessages(msg);
		}
	});
	branchDelta.on("submit", (content, branchMetadata) => {
		branchPending.push({ content, branchMetadata });
	});

	return () => {
		const pending = branchPending.splice(0);
		pending.forEach((p) => {
			assert(p.channelMetadata === undefined, "cannot rebase with remote changes");
			branchDelta.reSubmit(p.content, p.branchMetadata);
		});
		const rebased = branchPending.splice(0);
		ignoreChannelSubmits = true;
		rebased.forEach((p) => {
			const channelMetadata = channelDelta.applyStashedOp(p.content);
			branchPending.push({ ...p, channelMetadata });
			channelDelta.submit(p.content, channelMetadata);
		});
		ignoreChannelSubmits = false;
	};
}

function createRemoteAndLocalProcessingMerge(
	branchDelta: ChannelDeltaConnection,
	channelDelta: ChannelDeltaConnection,
) {
	const branchPending: {
		content: unknown;
		branchMetadata: unknown;
		channelMetadata?: Set<unknown>;
	}[] = [];
	let ignoreChannelSubmits = false;

	branchDelta.on("submit", (content, branchMetadata) =>
		branchPending.push({ content, branchMetadata }),
	);

	channelDelta.on("submit", (content, channelMetadata) => {
		if (!ignoreChannelSubmits) {
			// pretend the channel's op in the branches op
			const branchMetadata = branchDelta.applyStashedOp(content);
			branchPending.push({
				content,
				branchMetadata,
				channelMetadata: new Set([channelMetadata]),
			});
		}
	});

	channelDelta.on("process", (message) => {
		const { local } = message;
		if (local) {
			let pendingIndex = branchPending.findIndex(
				(b) => b.channelMetadata?.has(channelMetadata) === true,
			);
			assert(pendingIndex !== -1, "must have pending change mapped to remote");
			// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
			const { channelMetadata, content, branchMetadata } = branchPending[0]!;
			while (pendingIndex > 0) {
				assert(channelMetadata === undefined, "can;t move shared changes");
				branchDelta.reSubmit(content, branchMetadata);
				branchPending.shift();
				pendingIndex--;
			}

			channelMetadata?.delete(channelMetadata);
			if (channelMetadata?.size === 0) {
				// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
				const branchData = branchPending.shift()!;
				branchDelta.process(
					{ ...message, contents: branchData.content },
					true,
					branchData.branchMetadata,
				);
			}
		} else {
			branchDelta.process(message, false, undefined);
		}
	});

	channelDelta.on("pre-resubmit", (_, originalChannelMetadata) => {
		// get the original branch data from original submit metadata
		const pendingIndex = branchPending.findIndex(
			(b) => b.channelMetadata?.has(originalChannelMetadata) === true,
		);
		assert(pendingIndex !== -1, "should exist if tracking");

		const newChannelMetadata = new Set<unknown>();
		// capture the new branch metadata if submitted

		const onResubmitSubmit = (c, channelMetadata) => newChannelMetadata.add(channelMetadata);

		ignoreChannelSubmits = true;
		channelDelta.on("submit", onResubmitSubmit);
		channelDelta.once("post-resubmit", () => {
			// stop capturing resubmit metadatas
			channelDelta.off("submit", onResubmitSubmit);
			ignoreChannelSubmits = false;
			assert(newChannelMetadata.size > 0, "must have at least one outstanding op");
			branchPending[pendingIndex].channelMetadata = newChannelMetadata;
		});
	});

	return () => {
		const pending = branchPending.splice(0);
		pending.forEach((p) => {
			assert(p.channelMetadata === undefined, "cannot rebase with remote changes");
			branchDelta.reSubmit(p.content, p.branchMetadata);
		});
		const rebased = branchPending.splice(0);
		ignoreChannelSubmits = true;
		rebased.forEach((p) => {
			const channelMetadata = channelDelta.applyStashedOp(p.content);
			branchPending.push({ ...p, channelMetadata: new Set([channelMetadata]) });
			channelDelta.submit(p.content, channelMetadata);
		});
		ignoreChannelSubmits = false;
	};
}
